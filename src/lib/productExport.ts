/**
 * Product Cards Export Utilities
 * ZIP export and library save functionality
 */

import JSZip from "jszip";

// ===== TYPES =====

export interface SlideData {
  id: string;
  imageUrl: string;
  text?: string;
}

export interface ProductExportData {
  slides: SlideData[];
  productTitle: string;
  productBenefits: string[];
  marketplace: string;
  modeId: string;
  templateStyle: string;
  nicheId?: string | null;
  sceneId?: string | null;
  brandTemplateId?: string | null;
}

export interface ProductTexts {
  seoTitle: string;
  bullets: string[];
  description: string;
  keywords: string[];
}

// ===== SLIDE FILENAMES =====

const SLIDE_FILENAMES: Record<number, string> = {
  0: "01_cover",
  1: "02_benefits",
  2: "03_specs",
  3: "04_howto",
  4: "05_bundle",
  5: "06_delivery",
};

function getSlideFilename(index: number): string {
  return SLIDE_FILENAMES[index] ?? `${String(index + 1).padStart(2, "0")}_slide`;
}

// ===== IMAGE UTILITIES =====

/**
 * Fetch image as blob from URL or data URL
 */
async function fetchImageAsBlob(imageUrl: string): Promise<Blob> {
  // Handle data URLs
  if (imageUrl.startsWith("data:")) {
    const response = await fetch(imageUrl);
    return response.blob();
  }

  // Handle blob URLs
  if (imageUrl.startsWith("blob:")) {
    const response = await fetch(imageUrl);
    return response.blob();
  }

  // Handle regular URLs
  const response = await fetch(imageUrl, { mode: "cors" });
  if (!response.ok) {
    throw new Error(`Failed to fetch image: ${response.statusText}`);
  }
  return response.blob();
}

/**
 * Convert blob to JPEG if needed
 */
async function convertToJpeg(blob: Blob): Promise<Blob> {
  // If already JPEG, return as-is
  if (blob.type === "image/jpeg") {
    return blob;
  }

  return new Promise((resolve, reject) => {
    const img = new Image();
    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");

    img.onload = () => {
      canvas.width = img.naturalWidth;
      canvas.height = img.naturalHeight;
      
      if (ctx) {
        // Fill white background for transparency
        ctx.fillStyle = "#FFFFFF";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(img, 0, 0);
        
        canvas.toBlob(
          (jpegBlob) => {
            if (jpegBlob) {
              resolve(jpegBlob);
            } else {
              reject(new Error("Failed to convert to JPEG"));
            }
          },
          "image/jpeg",
          0.92
        );
      } else {
        reject(new Error("Failed to get canvas context"));
      }
    };

    img.onerror = () => reject(new Error("Failed to load image"));
    img.src = URL.createObjectURL(blob);
  });
}

// ===== TEXT GENERATION =====

/**
 * Generate product texts from export data
 */
export function generateProductTexts(data: ProductExportData): ProductTexts {
  const { productTitle, productBenefits, marketplace } = data;

  // SEO Title (marketplace optimized)
  const seoTitle = productTitle
    ? `${productTitle} | ${marketplace.toUpperCase()} | Быстрая доставка`
    : "Товар высокого качества | Быстрая доставка";

  // Bullets (formatted benefits)
  const bullets = productBenefits
    .filter(b => b.trim())
    .map(b => `✓ ${b.trim()}`);

  // Description
  const description = bullets.length > 0
    ? `${productTitle || "Товар"}. ${bullets.map(b => b.replace("✓ ", "")).join(". ")}.`
    : productTitle || "";

  // Keywords
  const keywords = [
    productTitle,
    marketplace,
    ...productBenefits.filter(b => b.trim()).slice(0, 3),
  ].filter(Boolean) as string[];

  return {
    seoTitle,
    bullets,
    description,
    keywords,
  };
}

/**
 * Format texts for export file
 */
function formatTextsForExport(texts: ProductTexts): string {
  const lines: string[] = [
    "=== SEO TITLE ===",
    texts.seoTitle,
    "",
    "=== BULLETS ===",
    ...texts.bullets,
    "",
    "=== DESCRIPTION ===",
    texts.description,
    "",
    "=== KEYWORDS ===",
    texts.keywords.join(", "),
    "",
    "---",
    `Generated by LensRoom.ru • ${new Date().toLocaleDateString("ru-RU")}`,
  ];

  return lines.join("\n");
}

// ===== ZIP EXPORT =====

/**
 * Create ZIP archive with product images and texts
 */
export async function createProductZip(data: ProductExportData): Promise<Blob> {
  const zip = new JSZip();

  // Add images
  const completedSlides = data.slides.filter(s => s.imageUrl);
  
  for (let i = 0; i < completedSlides.length; i++) {
    const slide = completedSlides[i];
    try {
      const imageBlob = await fetchImageAsBlob(slide.imageUrl);
      const jpegBlob = await convertToJpeg(imageBlob);
      const filename = `${getSlideFilename(i)}.jpg`;
      zip.file(filename, jpegBlob);
    } catch (error) {
      console.error(`Failed to add image ${i}:`, error);
    }
  }

  // Add texts
  const texts = generateProductTexts(data);
  const textsContent = formatTextsForExport(texts);
  zip.file("texts.txt", textsContent);

  // Generate ZIP
  return zip.generateAsync({ 
    type: "blob",
    compression: "DEFLATE",
    compressionOptions: { level: 6 },
  });
}

/**
 * Download ZIP file
 */
export function downloadBlob(blob: Blob, filename: string): void {
  const url = URL.createObjectURL(blob);
  const link = document.createElement("a");
  link.href = url;
  link.download = filename;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}

/**
 * Export product cards as ZIP
 */
export async function exportProductZip(
  data: ProductExportData,
  filename?: string
): Promise<void> {
  const zipBlob = await createProductZip(data);
  const timestamp = new Date().toISOString().slice(0, 10);
  const defaultFilename = `product_cards_${data.marketplace}_${timestamp}.zip`;
  downloadBlob(zipBlob, filename ?? defaultFilename);
}

// ===== COPY TEXTS =====

/**
 * Copy all texts to clipboard as formatted string
 */
export async function copyProductTexts(data: ProductExportData): Promise<boolean> {
  const texts = generateProductTexts(data);
  const content = formatTextsForExport(texts);
  
  try {
    await navigator.clipboard.writeText(content);
    return true;
  } catch {
    return false;
  }
}

// ===== LIBRARY STORAGE =====

const LIBRARY_KEY = "lensroom_library_products";
const MAX_LIBRARY_ITEMS = 50;

export interface ProductLibraryItem {
  id: string;
  createdAt: string;
  productTitle: string;
  marketplace: string;
  modeId: string;
  templateStyle: string;
  nicheId?: string | null;
  sceneId?: string | null;
  brandTemplateId?: string | null;
  slideCount: number;
  /** Base64 encoded thumbnail of first slide */
  thumbnailBase64?: string;
  /** Image URLs (may be blob URLs that expire) */
  imageUrls: string[];
  texts: ProductTexts;
}

function generateId(): string {
  return `prod_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;
}

/**
 * Get image as base64 data URL
 */
async function imageToBase64(imageUrl: string, maxSize = 200): Promise<string | undefined> {
  try {
    const blob = await fetchImageAsBlob(imageUrl);
    
    return new Promise((resolve) => {
      const img = new Image();
      const canvas = document.createElement("canvas");
      const ctx = canvas.getContext("2d");

      img.onload = () => {
        // Scale down for thumbnail
        const scale = Math.min(maxSize / img.naturalWidth, maxSize / img.naturalHeight, 1);
        canvas.width = img.naturalWidth * scale;
        canvas.height = img.naturalHeight * scale;
        
        if (ctx) {
          ctx.fillStyle = "#FFFFFF";
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
          resolve(canvas.toDataURL("image/jpeg", 0.7));
        } else {
          resolve(undefined);
        }
      };

      img.onerror = () => resolve(undefined);
      img.src = URL.createObjectURL(blob);
    });
  } catch {
    return undefined;
  }
}

/**
 * Save product to library
 */
export async function saveProductToLibrary(data: ProductExportData): Promise<ProductLibraryItem> {
  const existing = getProductLibrary();
  
  // Create thumbnail from first slide
  const firstSlide = data.slides.find(s => s.imageUrl);
  const thumbnailBase64 = firstSlide ? await imageToBase64(firstSlide.imageUrl) : undefined;

  const item: ProductLibraryItem = {
    id: generateId(),
    createdAt: new Date().toISOString(),
    productTitle: data.productTitle,
    marketplace: data.marketplace,
    modeId: data.modeId,
    templateStyle: data.templateStyle,
    nicheId: data.nicheId,
    sceneId: data.sceneId,
    brandTemplateId: data.brandTemplateId,
    slideCount: data.slides.filter(s => s.imageUrl).length,
    thumbnailBase64,
    imageUrls: data.slides.filter(s => s.imageUrl).map(s => s.imageUrl),
    texts: generateProductTexts(data),
  };

  // Add to beginning, enforce limit
  const updated = [item, ...existing].slice(0, MAX_LIBRARY_ITEMS);
  
  if (typeof window !== "undefined") {
    localStorage.setItem(LIBRARY_KEY, JSON.stringify(updated));
  }

  return item;
}

/**
 * Get all products from library
 */
export function getProductLibrary(): ProductLibraryItem[] {
  if (typeof window === "undefined") return [];
  
  try {
    const json = localStorage.getItem(LIBRARY_KEY);
    if (!json) return [];
    const data = JSON.parse(json);
    return Array.isArray(data) ? data : [];
  } catch {
    return [];
  }
}

/**
 * Delete product from library
 */
export function deleteProductFromLibrary(id: string): boolean {
  const existing = getProductLibrary();
  const filtered = existing.filter(item => item.id !== id);
  
  if (filtered.length === existing.length) return false;
  
  if (typeof window !== "undefined") {
    localStorage.setItem(LIBRARY_KEY, JSON.stringify(filtered));
  }
  
  return true;
}

/**
 * Clear all products from library
 */
export function clearProductLibrary(): void {
  if (typeof window !== "undefined") {
    localStorage.removeItem(LIBRARY_KEY);
  }
}




